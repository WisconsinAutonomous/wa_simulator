:mod:`wa_simulator.vehicle`
===========================

.. py:module:: wa_simulator.vehicle

.. Module Contents
.. ---------------


.. raw:: html

   <h2>Classes</h2>

.. autoapisummary::
  :nosignatures:

  wa_simulator.vehicle.WAVehicle
  wa_simulator.vehicle.WALinearKinematicBicycle

.. py:class:: WAVehicle(system: WASystem, vehicle_inputs: WAVehicleInputs, filename=None)

   Bases: :class:`wa_simulator.base.WABase`

   Base class for a WAVehicle.

   To implement a new vehicle model, override this class. A WAVehicle should interact
   with the terrain/assets/world and take three inputs: steering, throttle, braking.

   :Parameters: * **system** (*WASystem*) -- the system used to run the simulation
                * **vehicle_inputs** (*WAVehicleInputs*) -- The vehicle inputs
                * **filename** (*str, optional*) -- Filename to be used for visualization properties

   .. method:: get_visual_properties(self) -> dict

      Get visual properties for visualizing the vehicle

      .. todo::
          Define the visual properties required

      :returns: *dict* -- the visual properties


   .. method:: synchronize(self, time: float)
      :abstractmethod:

      Update the state of this component at the current time.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      As opposed to :meth:`~advance`, this method gets the current time of the simulation. As menthioned earlier,
      :meth:`~advance` and a user defined `time` variable could be used to instead to hold the current state of the simulation. However,
      to aid in generality of the package, this method is provided to simply provide the current time of the simulation to the user in a decoupled
      manner from the :meth:`~advance` method.

      :Parameters: **time** (*float*) -- The current time to synchronize to


   .. method:: advance(self, step: float)
      :abstractmethod:

      Advance the state of this component by the specified time step.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      :Parameters: **step** (*float*) -- The step size to advance this component by


   .. method:: is_ok(self) -> bool

      Check whether this component is still alive.

      Depending the type of component, a specific element may "fail". For example, when
      a visualization is used that presents a GUI/window, if the user closes that display,
      this would be considered a component death. Therefore, :meth:`~is_ok` should then return
      False.

      :returns: *bool* -- True if still alive, false otherwise


   .. method:: get_tire_radius(self, axle: str) -> float
      :abstractmethod:

      The radius of the front or rear tires

      :Parameters: **axle** (*str*) -- Either 'Front' or 'Rear' (case insensitive).

      :returns: *float* -- The radius of the tires on the specified axle


   .. method:: get_pos(self) -> WAVector
      :abstractmethod:

      Get the center of mass (COM) position of the vehicle.

      :returns: *WAVector* -- the position of the vehicle


   .. method:: get_rot(self) -> WAQuaternion
      :abstractmethod:

      Get the rotation about the center of mass (COM) of the vehicle

      :returns: *WAQuaternion* -- the vehicles orientation


   .. method:: get_pos_dt(self) -> WAVector
      :abstractmethod:

      Get the instantaneous velocity of the vehicle

      :returns: *WAVector* -- The velocity where X is forward, Z is up and Y is left (ISO standard)


   .. method:: get_rot_dt(self) -> WAQuaternion
      :abstractmethod:

      Get the angular velocity of the vehicle

      :returns: *WAQuaternion* -- The angular velocity


   .. method:: get_pos_dtdt(self) -> WAVector
      :abstractmethod:

      Get the acceleration of the vehicle

      :returns: *WAVector* -- The acceleration where X is forward, Z is up and Y is left (ISO standard)


   .. method:: get_rot_dtdt(self) -> WAQuaternion
      :abstractmethod:

      Get the angular acceleration of the vehicle

      :returns: *WAQuaternion* -- The angular acceleration



.. py:class:: WALinearKinematicBicycle(system: WASystem, vehicle_inputs: WAVehicleInputs, filename: str, init_pos: WAVector = WAVector(), init_rot: WAQuaternion = WAQuaternion.from_z_rotation(0), init_pos_dt: WAVector = WAVector())

   Bases: :class:`wa_simulator.vehicle.WAVehicle`

   A linear, kinematic bicycle model

   :Parameters: * **system** (*WASystem*) -- the system used to run the simulation
                * **vehicle_inputs** (*WAVehicleInputs*) -- The vehicle inputs
                * **filename** (*str*) -- json specification file used to describe the parameters for the vehicle
                * **init_pos** (*WAVector*) -- initial position
                * **init_rot** (*WAQuaternion*) -- initial rotation
                * **init_pos_dt** (*WAVector*) -- initial velocity

   .. method:: synchronize(self, time)

      Update the state of this component at the current time.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      As opposed to :meth:`~advance`, this method gets the current time of the simulation. As menthioned earlier,
      :meth:`~advance` and a user defined `time` variable could be used to instead to hold the current state of the simulation. However,
      to aid in generality of the package, this method is provided to simply provide the current time of the simulation to the user in a decoupled
      manner from the :meth:`~advance` method.

      :Parameters: **time** (*float*) -- The current time to synchronize to


   .. method:: advance(self, step)

      Advance the state of this component by the specified time step.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      :Parameters: **step** (*float*) -- The step size to advance this component by


   .. method:: get_tire_radius(self, axle: str) -> float

      The radius of the front or rear tires

      :Parameters: **axle** (*str*) -- Either 'Front' or 'Rear' (case insensitive).

      :returns: *float* -- The radius of the tires on the specified axle


   .. method:: get_pos(self) -> WAVector

      Get the center of mass (COM) position of the vehicle.

      :returns: *WAVector* -- the position of the vehicle


   .. method:: get_rot(self) -> WAQuaternion

      Get the rotation about the center of mass (COM) of the vehicle

      :returns: *WAQuaternion* -- the vehicles orientation


   .. method:: get_pos_dt(self) -> WAVector

      Get the instantaneous velocity of the vehicle

      :returns: *WAVector* -- The velocity where X is forward, Z is up and Y is left (ISO standard)


   .. method:: get_rot_dt(self) -> WAQuaternion

      Get the angular velocity of the vehicle

      :returns: *WAQuaternion* -- The angular velocity


   .. method:: get_pos_dtdt(self) -> WAVector

      Get the acceleration of the vehicle

      :returns: *WAVector* -- The acceleration where X is forward, Z is up and Y is left (ISO standard)


   .. method:: get_rot_dtdt(self) -> WAQuaternion

      Get the angular acceleration of the vehicle

      :returns: *WAQuaternion* -- The angular acceleration






.. raw:: html

   <h2>Methods</h2>

.. autoapisummary::
  :nosignatures:

   wa_simulator.vehicle.load_properties_from_json

.. function:: load_properties_from_json(filename: str, prop: str) -> dict

   Load a specified property from a json specification file

   Will load a json file and extract the passed property field for use
   by the underyling vehicle object

   :Parameters: * **filename** (*str*) -- the filename location within the set WA data folder for the json file
                * **property** (*str*) -- the property to get. Ex: "Vehicle Properties"

   :raises ValueError: The property field isn't found

   :returns: *dict* -- the property field extracted from the json file





.. .. .. autoapi-nested-parse::
..
..    Wisconsin Autonomous - https://wa.wisc.edu

   Copyright (c) 2021 wa.wisc.edu
   All rights reserved.

   Use of this source code is governed by a BSD-style license that can be found
   in the LICENSE file at the top level of the repo

..
.. 