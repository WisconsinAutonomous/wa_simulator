:mod:`wa_simulator.bridge`
==========================

.. py:module:: wa_simulator.bridge

.. Module Contents
.. ---------------


.. raw:: html

   <h2>Classes</h2>

.. autoapisummary::
  :nosignatures:

  wa_simulator.bridge.WABridge

.. py:class:: WABridge(system: WASystem, hostname: str = 'localhost', port: int = 5555, server: bool = True, use_ack: bool = True, is_synchronous: bool = True, ignore_unknown_messages: bool = True)

   Bases: :class:`wa_simulator.base.WABase`

   Base class for a bridge interface between the simulator and an external entity

   There are many applications where it's desired that `wa_simulator` communicates with external entities.
   For example, `Robot Operating System or ROS <https://www.ros.org/>_` is a popular tool for writing
   robotic control code. Simulation is a very valuable tool for testing, so being able to communicate
   with these external control stacks is an important feature.

   For each external entity that wants to be connected to, a new bridge object must be created. The `multiprocessing.connection` library
   will be used and it's `Listener <https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Listener>_` class.
   The messages will be sent as dictionaries of data and messages to be sent at each timestep will be accumulated to be sent as one large message.

   Message types are dynamic in types, form and structure; however, there are a few rules that must be abided by. First, sender names must be unique. The
   name will be used as the message identifier in the dictionary. Second, the structure of the message types will be infered, if possible. Otherwise, they must be
   explicitely provided in the calling method when adding the sender.

   :Parameters: * **system** (*WASystem*) -- The system used to manage the simulation
                * **hostname** (*str*) -- The hostname of the client entity
                * **port** (*int*) -- The port to attach to
                * **use_ack** (*bool*) -- Specify whether to use an acknowledgement when sending a message to ensure the client got the message. Defaults to True.
                * **is_synchronous** (*bool*) -- Specify whether the sender and receivers are in synchronous mode. If yes, on each step, a message will be sent and received. If not, will not wait for a message to be received.
                * **ignore_unknown_messages** (*bool*) -- If a message is received with an unknown name (not registered with :meth:`~add_receiver`), ignore it. Defaults to True. If False, will raise an error.

   .. method:: connect(self)

      Method that connects with the external entity.

      Typically called by :class:`~WASimulationManager`, but okay to call outside. Will only connect to one client at
      the hostname and port provided to the constructor.

      If this bridge is a server, a ``multiprocessing.Connection.Listener`` object is used. Otherwise, a ``multiprocessing.Connection.Client`` object is used.
      See the `Listener <https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Listener>_`
      or `Client <https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Client>_` docs to see possible errors that may be raised.


   .. method:: add_sender(self, name: str, component: WABase, message_generator: Callable[[WABase], dict] = None)

      Adds a sender component that has outgoing messages

      To actually send data from the simulation to the external client, this method (or it's derivatives) must be called
      to explicitly tell the bridge what information to send.

      The format of the outgoing message is inferred, unless ``message_generator`` is not ``None``. If the message structure cannot
      be inferred and ``message_generator`` is ``None``, a ``RuntimeError`` will be raised.

      :Parameters: * **name** (*str*) -- The unique message name/identifier (think ROS topic)
                   * **component** (*WABase*) -- The :class:`~WABase` component the message data will be generated from
                   * **message_generator** (*Callable[[WABase], dict]*) -- A custom method that generates a dict message to be sent from the specified component

      :raises ValueError: if ``name`` is not unique (there is already a message identifier with that name)
      :raises RuntimeError: If the message structure cannot be inferred and a message generator method is not provided


   .. method:: add_receiver(self, name: str = '', element: Any = None, message_parser: Callable[[Any], dict] = None)

      Adds a receiver element that has incoming messages

      A receiver either has a name and element, a name, element and message_perser, or just a message_parser. If a name
      and element are provided, the message_parser is attempted to be inferred. If it can't be inferred, a error will be raised.
      If it can't be inferred, you should provied a message_parser. The name will be used to determine what message_parser to call when
      a message is received. If neither a name or element are provided, a message_parser must be provided. In this case, a
      all received messages that do not have a callback will call this message_parser. Think of this as a 'global message listener'.

      The ``name`` need not be unique from any senders in the class, only from other receivers.

      "element" is used instead of "component" because the element doesn't necessarily need to be a WABase derived class.

      On each synchronization step, the receiver message parse method will be called. To have the listener be polled for messages,
      a single receiver must be added. Further, for the receiver parser to be called, the name attached to the message and the receiver
      added here must match. If there is no match, either the message will be ignored (unless ``ignore_unknown_messages`` is set to fault in
      the constructor) or if there is a global message listener, it's callback will be called.

      The format of the incoming message is inferred, unless ``message_parser`` is not ``None``. If the message structure cannot
      be inferred and ``message_parser`` is ``None``, a ``RuntimeError`` will be raised.

      :Parameters: * **name** (*str*) -- The unique message name/identifier (think ROS topic)
                   * **element** (*Any*) -- The element the message data will be used to populate or change. Should be an object so it's passed by reference.
                   * **message_parser** (*Callable[[Any, dict], Any]*) -- A custom method that parses the received messag

      :raises ValueError: if ``name`` is not unique (there is already a message identifier with that name)
      :raises RuntimeError: If the message structure cannot be inferred and a message parser method is not provided


   .. method:: synchronize(self, time: float)

      Synchronizes with the external entity

      Will accumulate the messages to be sent and then send them. And then will receive any messages
      from receivers.

      :raises RuntimeError: If an acknowledgement is not received from the client after data is sent or it is corrupt.


   .. method:: advance(self, step: float)

      Advance the state of the bridge

      Will receive any messages from the client, if there are registered receivers.

      :raises RuntimeError: Received an unknown message (only if ignore_unknown_messages is False)


   .. method:: is_ok(self) -> bool

      Check whether this component is still alive.

      Depending the type of component, a specific element may "fail". For example, when
      a visualization is used that presents a GUI/window, if the user closes that display,
      this would be considered a component death. Therefore, :meth:`~is_ok` should then return
      False.

      :returns: *bool* -- True if still alive, false otherwise


   .. method:: set_timeout(self, timeout: bool)

      Set the timeout for the acknowledgement

      If acknowledgements are utilized, the timeout value is used to determine how long to wait before throwing an error that an ack was never received. This
      method provides the ability to set this value.

      :Parameters: **timeout** (*bool*) -- The new timeout value







.. .. .. autoapi-nested-parse::
..
..    Wisconsin Autonomous - https://wa.wisc.edu

   Copyright (c) 2021 wa.wisc.edu
   All rights reserved.

   Use of this source code is governed by a BSD-style license that can be found
   in the LICENSE file at the top level of the repo

..
.. 