:mod:`wa_simulator.track`
=========================

.. py:module:: wa_simulator.track

.. Module Contents
.. ---------------


.. raw:: html

   <h2>Classes</h2>

.. autoapisummary::
  :nosignatures:

  wa_simulator.track.WATrack

.. py:class:: WATrack(center: WAPath, left: WAPath, right: WAPath, **kwargs)

   Base Track object. Basically holds three WAPaths: centerline and two boundaries. This class provides convenience functions so that it is easier to write various track related code

   Does *not* inherit from WABase. This is a static component, so it does not need to update.

   :Parameters: * **center** (*WAPath*) -- The centerline of the track.
                * **left** (*WAPath*) -- The "left" side boundary. Side is determined by orientation from the centerline by index.
                * **right** (*WAPath*) -- The "right" side boundary. Side is determined by orientation from the centerline by index.
                * **kwargs** -- Extra parameters that are used for the track

   :ivar center: The centerline of the track.
   :vartype center: WAPath
   :ivar left: The "left" side boundary. Side is determined by orientation from the centerline by index.
   :vartype left: WAPath
   :ivar right: The "right" side boundary. Side is determined by orientation from the centerline by index.

   :vartype right: WAPath

   .. method:: inside_boundaries(self, point: WAVector) -> bool

      Check whether the passed point is within the track boundaries

      Implementation is explained `here <https://stackoverflow.com/a/33155594>`_.

      :Parameters: **point** (*WAVector*) -- point to check whether it's inside the track boundaries

      :returns: *bool* -- is the point inside the boundaries?


   .. method:: get_detected_track(self, position: WAVector, orientation: WAQuaternion, fov: float, detection_range: float) -> Tuple[List[WAVector], List[WAVector]]

      Get a list of points defining the detectable track

      This method is useful to "fake" perception algorithms. This will allow localization or controls
      algorithms to be tested without needing to actually run any perception detection runs. Further, it
      means you don't need a camera or lidar sensors to detect the track.

      The detected track will be calculated based on the position and orientation of the vehicle, the
      detection FOV, and the detection range.

      :Parameters: * **position** (*WAVector*) -- The position of the vehicle
                   * **orientation** (*WAQuaternion*) -- The orientation of the vehicle
                   * **fov** (*float*) -- The horizontal field of view that defines the detection width (in degrees)
                   * **detection_range** (*float*) -- The distance from the vehicle that the furthest detection point is. Anything within the fov but beyond the range is ignored.

      :returns: *List[WAVector], List[WAVector]* -- List of points defining the detected track. First list is the left boundary and the second list is the right list.


   .. method:: get_mapped_track(self, position: WAVector, orientation: WAQuaternion, fov: float, detection_range: float) -> Tuple[List[WAVector], List[WAVector], List[WAVector]]

      Get a list of points defining the mapped track the vehicle has progressed through

      This method is useful to "fake" perception/state estimation algorithms. This will allow localization or controls
      algorithms to be tested without needing to actually run any perception detection or state estimation algorithms. Further, it
      means you don't need any sensors to detect the track.

      The mapped track will be calculated based on the position and orientation of the vehicle, the
      detection FOV, the detection range, and the past positions of the vehicle

      Note: There may be an issue with unordered points

      :Parameters: * **position** (*WAVector*) -- The position of the vehicle
                   * **orientation** (*WAQuaternion*) -- The orientation of the vehicle
                   * **fov** (*float*) -- The horizontal field of view that defines the detection width (in degrees)
                   * **detection_range** (*float*) -- The distance from the vehicle that the furthest detection point is. Anything within the fov but beyond the range is ignored.

      :returns: *List[WAVector], List[WAVector]* -- left and right boundaries mapped over time in reference to the initial position
                List[WAVector], List[WAVector], List[WAVector]: gps coordinates of the centerline, centerline points in reference to the initial position, the distance between the centerline and the left and right boundaries encoded in the x and y values of a WAVector, respectively.


   .. method:: plot(self, show=True, center_args: dict = {}, left_args: dict = {}, right_args: dict = {})

      Plot the path. Most likely plotter is matplotlib, but technically anything can be used.

      :Parameters: * **show** (*bool*) -- Immediately show the plot? Defaults to True.
                   * **center_args** (*dict*) -- Keyworded parameters passed to the center plot method
                   * **left_args** (*dict*) -- Keyworded parameters passed to the left plot method
                   * **right_args** (*dict*) -- Keyworded parameters passed to the right plot method






.. raw:: html

   <h2>Methods</h2>

.. autoapisummary::
  :nosignatures:

   wa_simulator.track.create_track_from_json
   wa_simulator.track.create_variable_width_track
   wa_simulator.track.create_constant_width_track

.. function:: create_track_from_json(filename: str, environment: WAEnvironment = None) -> 'WATrack'

   Creates a WATrack object from a json specification file. Supports two templates, "Constant Width Track" and "Variable Width Track".

   json file options:

   * Origin(``list``, required): The GPS origin of the first centerline point

   * Visualization (``dict``, optional): Additional visualization properties.

     * Center/Right/Left (``dict``, optional): The each paths visualization properties

       * Color (``list``, optional): Visualization color.

       * Object (``dict``, optional): An object that is placed along the path. Only parsed if ``environment`` is set.

         * Size (``list``, optional): Size of the objects.

         * Color (``list``, optional): Color of the objects.

         * Color #1 (``list``, optional): Color of an alternating set of objects. Must come with Color #2 and without Color.

         * Color #2 (``list``, optional): Color of an alternating set of objects. Must come with Color #1 and without Color.

         * Mode (``str``, optional): The mode for the object placement along the path. Options include 'Solid', 'Dashed' (3[m] separation) and 'Spread' (6[m] separation).

   Constant Width Track json file options:

   * Center Input File (``str``, required): A json file describing the centerline. Loaded using :meth:`~create_path_from_json`

   * Width (``float``, required): The constant width between the left and right boundaries of the track.

   Variable Width Track json file options:

   * Left Input File (``str``, required): A json file describing the left boundary. Loaded using :meth:`~create_path_from_json`

   * Right Input File (``str``, required): A json file describing the right boundary. Loaded using :meth:`~create_path_from_json`

   :Parameters: * **filename** (*str*) -- The json specification that describes the track
                * **environment** (*WAEnvironment, optional*) -- Adds objects to the environment, if present. Defaults to None (doesn't parse objects).

   :returns: *WATrack* -- The created track


.. function:: create_variable_width_track(left: WAPath, right: WAPath) -> 'WATrack'

   Generates a WATrack given paths of the left and right boundaries. Simply "walks" along the left and right boundaries and computes midpoints to form the centerline.
   NOTE: Besides `num_points` and `is_closed`, this method assumes the parameters of the left and right paths are the same.

   :Parameters: * **left** (*WAPath*) -- The left path
                * **right** (*WAPath*) -- The right path

   :returns: *WATrack* -- The created track


.. function:: create_constant_width_track(center: WAPath, width: float) -> 'WATrack'

   Generates a WATrack given a centerline and a constant width. Simply "walks" along path and takes the normal from the center at a distance equal to width/2

   :Parameters: * **center** (*WAPath*) -- The centerline of the track
                * **width** (*float*) -- The constant distance between the left and right boundaries(distance between centerline and a boundary is width/2)

   :returns: *WATrack* -- The created track





.. .. .. autoapi-nested-parse::
..
..    Wisconsin Autonomous - https://wa.wisc.edu

   Copyright (c) 2021 wa.wisc.edu
   All rights reserved.

   Use of this source code is governed by a BSD-style license that can be found
   in the LICENSE file at the top level of the repo

..
.. 