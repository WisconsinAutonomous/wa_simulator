:mod:`wa_simulator.chrono.visualization`
========================================

.. py:module:: wa_simulator.chrono.visualization

.. Module Contents
.. ---------------


.. raw:: html

   <h2>Classes</h2>

.. autoapisummary::
  :nosignatures:

  wa_simulator.chrono.visualization.WAChronoIrrlicht
  wa_simulator.chrono.visualization.WAChronoSensorVisualization

.. py:class:: WAChronoIrrlicht(system: WAChronoSystem, vehicle: WAChronoVehicle, vehicle_inputs: WAVehicleInputs, environment: WAEnvironment = None, opponents: list = [], record: bool = False, record_folder: str = 'OUTPUT/', should_bind: bool = True)

   Bases: :class:`wa_simulator.visualization.WAVisualization`

   Chrono irrlicht visualization wrapper. Sets default values for a Vehicle irr app

   :Parameters: * **system** (*WAChronoSystem*) -- holds information regarding the simulation and performs dynamic updates
                * **vehicle** (*WAChronoVehicle*) -- vehicle that holds the Chrono vehicle
                * **vehicle_inputs** (*WAVehicleInputs*) -- the vehicle inputs
                * **environment** (*WAEnvironment, optional*) -- An environment with various world assets to visualize. Defaults to None (doesn't visualize anything).
                * **opponents** (*list, optional*) -- Opponents present in the simulation. The camera will track :attr:`~vehicle` not any opponent.
                * **record** (*bool, optional*) -- If set to true, images will be saved under record_filename. Defaults to False (doesn't save images).
                * **record_folder** (*str, optional*) -- The folder to save images to. Defaults to "OUTPUT/".
                * **should_bind** (*bool, optional*) -- After `all` assets have been added to the environment, irrlicht needs to "bind" and add the assets to the 3D rendered world. This can be done either on instantiation (True) or on the first update (False). Defaults to True.

   .. method:: synchronize(self, time: float)

      Synchronize the irrlicht app with the vehicle inputs at the passed time

      :Parameters: **time** (*double*) -- time to synchronize the simulation to


   .. method:: advance(self, step: float)

      Advance the state of the visualization by the specified step

      Will update the render only if the simulation step is a multiple of render steps

      :Parameters: **step** (*double*) -- step size to update the visualization by


   .. method:: is_ok(self)

      Checks if the irrlicht rending window is still alive

      :returns: *bool* -- whether the simulation is still alive


   .. method:: bind(self)

      Call AssetBindAll and AssetUpdateAll.


   .. method:: visualize(self, assets, *args, **kwargs)

      Helper method that visualizes some object(s) in the chosen visualizer

      Different visualizations will visualize the object(s) in different ways. This is an abstract method,
      so it must be implemented.

      :Parameters: * **assets** (*list*) -- The object(s) to visualize
                   * **\*args** -- Positional arguments that are specific to the underyling visualizer implementation
                   * **\*\*kwargs** -- Keyworded arguments that are specific to the underlying visualizer implementation



.. py:class:: WAChronoSensorVisualization(system: WAChronoSystem, vehicle: WAChronoVehicle, vehicle_inputs: WAVehicleInputs, environment: WAEnvironment = None, opponents: list = [], record: bool = False, record_folder: str = 'OUTPUT/')

   Bases: :class:`wa_simulator.visualization.WAVisualization`

   Chrono sensor visualization wrapper. Sets default values for a camera sensor

   :Parameters: * **system** (*WAChronoSystem*) -- holds information regarding the simulation and performs dynamic updates
                * **vehicle** (*WAChronoVehicle*) -- vehicle that holds the Chrono vehicle
                * **vehicle_inputs** (*WAVehicleInputs*) -- the vehicle inputs
                * **environment** (*WAEnvironment, optional*) -- An environment with various world assets to visualize. Defaults to None (doesn't visualize anything).
                * **opponents** (*list, optional*) -- Opponents present in the simulation. The camera will track :attr:`~vehicle` not any opponent.
                * **record** (*bool, optional*) -- If set to true, images will be saved under record_filename. Defaults to False (doesn't save images).
                * **record_folder** (*str, optional*) -- The folder to save images to. Defaults to "OUTPUT/".

   .. method:: synchronize(self, time: float)

      Update the state of this component at the current time.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      As opposed to :meth:`~advance`, this method gets the current time of the simulation. As menthioned earlier,
      :meth:`~advance` and a user defined `time` variable could be used to instead to hold the current state of the simulation. However,
      to aid in generality of the package, this method is provided to simply provide the current time of the simulation to the user in a decoupled
      manner from the :meth:`~advance` method.

      :Parameters: **time** (*float*) -- The current time to synchronize to


   .. method:: advance(self, step: float)

      Advance the state of this component by the specified time step.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      :Parameters: **step** (*float*) -- The step size to advance this component by


   .. method:: is_ok(self)

      Check whether this component is still alive.

      Depending the type of component, a specific element may "fail". For example, when
      a visualization is used that presents a GUI/window, if the user closes that display,
      this would be considered a component death. Therefore, :meth:`~is_ok` should then return
      False.

      :returns: *bool* -- True if still alive, false otherwise


   .. method:: visualize(self, assets, *args, **kwargs)

      Helper method that visualizes some object(s) in the chosen visualizer

      Different visualizations will visualize the object(s) in different ways. This is an abstract method,
      so it must be implemented.

      :Parameters: * **assets** (*list*) -- The object(s) to visualize
                   * **\*args** -- Positional arguments that are specific to the underyling visualizer implementation
                   * **\*\*kwargs** -- Keyworded arguments that are specific to the underlying visualizer implementation






.. raw:: html

   <h2>Methods</h2>

.. autoapisummary::
  :nosignatures:

   wa_simulator.chrono.visualization.draw_path_in_irrlicht
   wa_simulator.chrono.visualization.create_sphere_in_chrono
   wa_simulator.chrono.visualization.update_position_of_sphere

.. function:: draw_path_in_irrlicht(system: WAChronoSystem, path: WAPath)

   Draw a WAPath representation as a ChBezierCurve in irrlicht

   Basically just copies over the path's points into something viewable for Chrono

   :Parameters: * **system** (*WAChronoSystem*) -- system that manages the simulation
                * **path** (*WAPath*) -- WA path object to visualize in irrlicht


.. function:: create_sphere_in_chrono(system: WAChronoSystem, rgb=(1, 0, 0)) -> chrono.ChBodyEasySphere

   Create and add a sphere to the chrono world

   :Parameters: * **system** (*WASystem*) -- the system that manages the simulation
                * **rgb** (*tuple, optional*) -- (red, green, blue). Defaults to (1, 0, 0) or red.

   :returns: *chrono.ChBodyEasySphere* -- the sphere that was created


.. function:: update_position_of_sphere(sphere: chrono.ChBodyEasySphere, pos: WAVector)

   Update the position of a sphere being visualized in irrlicht

   :Parameters: * **sphere** (*chrono.ChBodyEasySphere*) -- the sphere to change the position of
                * **pos** (*WAVector*) -- the new position





.. .. .. autoapi-nested-parse::
..
..    Wisconsin Autonomous - https://www.wisconsinautonomous.org

   Copyright (c) 2021 wisconsinautonomous.org
   All rights reserved.

   Use of this source code is governed by a BSD-style license that can be found
   in the LICENSE file at the top level of the repo

..
.. 