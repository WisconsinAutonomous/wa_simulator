:mod:`wa_simulator.controller`
==============================

.. py:module:: wa_simulator.controller

.. Module Contents
.. ---------------


.. raw:: html

   <h2>Classes</h2>

.. autoapisummary::
  :nosignatures:

  wa_simulator.controller.WAController
  wa_simulator.controller.WAMatplotlibController
  wa_simulator.controller.WAROS2Controller

.. py:class:: WAController(system: WASystem, vehicle_inputs: WAVehicleInputs)

   Bases: :class:`wa_simulator.base.WABase`

   Base class for a controller

   Controllers are responsible for outputting a steering, throttle and braking value.
   This is done because in real life, those are the inputs our cars will have. The
   derived controller's (i.e. the new class that inherits from this class)
   responsibility is to take inputs from the simulation and return these values
   through the get_inputs method.

   :Parameters: * **system** (*WASystem*) -- The system used to manage the simulation
                * **vehicle_inputs** (*WAVehicleInputs*) -- The vehicle inputs

   :ivar steering: steering input.
   :vartype steering: float
   :ivar throttle: throttle input.
   :vartype throttle: float
   :ivar braking: braking input.

   :vartype braking: float

   .. method:: synchronize(self, time: float)
      :abstractmethod:

      Update the state of this component at the current time.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      As opposed to :meth:`~advance`, this method gets the current time of the simulation. As menthioned earlier,
      :meth:`~advance` and a user defined `time` variable could be used to instead to hold the current state of the simulation. However,
      to aid in generality of the package, this method is provided to simply provide the current time of the simulation to the user in a decoupled
      manner from the :meth:`~advance` method.

      :Parameters: **time** (*float*) -- The current time to synchronize to


   .. method:: advance(self, step: float)
      :abstractmethod:

      Advance the state of this component by the specified time step.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      :Parameters: **step** (*float*) -- The step size to advance this component by


   .. method:: is_ok(self) -> bool

      Check whether this component is still alive.

      Depending the type of component, a specific element may "fail". For example, when
      a visualization is used that presents a GUI/window, if the user closes that display,
      this would be considered a component death. Therefore, :meth:`~is_ok` should then return
      False.

      :returns: *bool* -- True if still alive, false otherwise


   .. method:: get_inputs(self) -> 'WAVehicleInputs'

      Get the vehicle inputs

      :returns: *WAVehicleInputs* -- The input class



.. py:class:: WAMatplotlibController(system: WASystem, vehicle_inputs: WAVehicleInputs, vis: WAMatplotlibVisualization)

   Bases: :class:`wa_simulator.controller._WAKeyboardController`

   Controls a vehicle via keyboard input from a matplotlib figure

   Will asynchronously change inputs based on user input to the matplotlib window.

   :Parameters: * **system** (*WASystem*) -- The system used to manage the simulation
                * **vehicle_inputs** (*WAVehicleInputs*) -- The vehicle inputs
                * **vis** (*WAMatplotlibVisualization*) -- The visualization that holds a matplotlib figure

   .. method:: synchronize(self, time)

      Synchronize the controller at the specified time

      Doesn't do anything since this controller is completely asynchronous

      :Parameters: **time** (*float*) -- the time at which the controller should synchronize all depends to



.. py:class:: WAROS2Controller(system: WASystem, vehicle_inputs: WAVehicleInputs)

   Bases: :class:`wa_simulator.controller.WAController`

   Controller that communicates with a ROS2 control stack

   :raises ImportError: Will be raised if ROS 2 is not found on the system.

   .. method:: synchronize(self, time: float)

      Update the state of this component at the current time.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      As opposed to :meth:`~advance`, this method gets the current time of the simulation. As menthioned earlier,
      :meth:`~advance` and a user defined `time` variable could be used to instead to hold the current state of the simulation. However,
      to aid in generality of the package, this method is provided to simply provide the current time of the simulation to the user in a decoupled
      manner from the :meth:`~advance` method.

      :Parameters: **time** (*float*) -- The current time to synchronize to


   .. method:: advance(self, step: float)

      Advance the state of this component by the specified time step.

      The primary reason to decouple the update method into two separate calls (i.e. :meth:`~synchronize` and :meth:`~advance`)
      is to provide flexibility to the user and is essentially semantic. In most simple cases, a user will only need one of the two.
      Furthermore, can only use :meth:`~advance` if they prefer and just update their own :code:`time` variable. Given the unknown use cases
      for the simulator at the time of writing, it was chosen to provide two different methods with similar functionality as to allow
      the user to choose their desired implementation, rather than the writers of this package.

      :Parameters: **step** (*float*) -- The step size to advance this component by







.. .. .. autoapi-nested-parse::
..
..    Wisconsin Autonomous - https://www.wisconsinautonomous.org

   Copyright (c) 2021 wisconsinautonomous.org
   All rights reserved.

   Use of this source code is governed by a BSD-style license that can be found
   in the LICENSE file at the top level of the repo

..
.. 